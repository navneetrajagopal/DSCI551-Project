# -*- coding: utf-8 -*-
"""SQL_LangChain3.0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ko1riru8oF-jggn7fCEmlhoozsxPRN6a

#Install
"""

# !pip3 install langchain openai pymysql sqlalchemy langchain_community langchain_experimental langgraph

"""#setup"""

#note for self clean up this has all of imports used
import os
import re
import pandas as pd
from langchain import OpenAI, SQLDatabase
from langchain.chains.llm import LLMChain
from langchain.prompts import PromptTemplate
from sqlalchemy import inspect
from langgraph.graph import StateGraph, END
from langchain_experimental.sql import SQLDatabaseChain
from sqlalchemy import text
from typing import TypedDict
from langgraph.graph import StateGraph, END

"""#OpenAI Key"""

os.environ['OPENAI_API_KEY'] = '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'

"""#Connect to DB"""

db = SQLDatabase.from_uri("mysql+pymysql://admin:Dsci-551@database-1.cjc8aikg8tmh.us-east-2.rds.amazonaws.com/DSCI551")
llm = OpenAI(temperature=0)
sql_chain = SQLDatabaseChain.from_llm(llm=llm, db=db, verbose=True)

"""#Create LLM AND DB Agent"""

#inspect the schema so the llm knows all columns
inspector = inspect(db._engine)
def describe_schema():
    schema = []
    for table in inspector.get_table_names():
        columns = inspector.get_columns(table)
        col_info = [f"{col['name']} ({col['type']})" for col in columns]
        schema.append(f"{table}: {', '.join(col_info)}")
    return "\n".join(schema)


llm_prompt = PromptTemplate.from_template(f"""
The database contains the following tables and their columns:

{describe_schema()}

ONLY output a valid MySQL SQL query. Do NOT explain or describe anything.
Do NOT guess or invent table or column names. Use only what's listed.

- All tables share the key UniqueID.
- To combine columns from different tables, use JOINs on UniqueID.
- Always use JOINs on UniqueID across the three main tables.
- Use only these valid table names:
  - OWNER_DETAIL
  - PROPERTY_INFO
  - SALE_TRANSACTIONS
- Do NOT use `OWNER_DETAILS`, `PROPERTY_INFOS`, etc.
- TABLE NAMES are always in CAPS
- When updating values check all tables - sometimes updates require referencing other tables
- HOUSE == PROPERTY, do not search for a specific house or property field it does not exist.
- LandUse exists but is not used to find houses (who owns a house will not use land use as house is property)
- Use `IS NULL` to match NULL fields instead of `= NULL`.
- Name is not the UniqueID
- Output valid, complete MySQL statements.
- Never return explanatory text before or after SQL.
- Use one statement per SQL query.
- Duplex is in land use
- Always quote string and VARCHAR values.
- You may insert only one column if that's all the user provided.
- Do not include the rest unless they are required (NOT NULL with no default).
- For example: INSERT INTO property_info (UniqueID) VALUES ('999');
- run SHOW TABLES when asked tabout the tables (ex: what are all the tables, what are the tables, what tables exit, show existing tables, show me the tables, show me all the tables, list the tables, list all the table)
- run SHOW COLUMNS from table_name when asked about the columns and names (ex: what are the column names in the tables, what  are all the col names, col names, column names, what are all the columns in table, what are the columnsin table, what columns exit in table, show existing columns in table, show me the columns in table, show me all the columns in table, list the columns in table, list all the columns in table)
- ex: run show columns from property_info when asked about columns in property info
- Do not reference or use the column Acreage in any part of the SQL query, including filters, joins, selects, or conditions unless explictely mentioned
- do not have a single line about property acerage unless specifically mentioned! (that means no property acerage is null no property acerage is not null nothing of property acerage should exist unless it is mentioned explicitly)
- when asking most or least you should limit to one
- Insert into OWNER_DETAILS when the user specifies an owner or OwnerName.
- The OWNER_DETAILS table has: UniqueID (primary key), OwnerName, ParcelID, etc.
- Do NOT insert into PROPERTY_INFO unless the instruction is about property details like acreage, bedrooms, or address.
- Insert into SALE_TRANSACTIONS when the user specifies a sale or transaction
- The SALE_TRANSACTION Table has UniqueID as primary key
- "Most expensive house" means the highest TotalValue, "cheapest house" means lowest total value from OWNER_DETAIL or highest/lowest SalePrice from SALE_TRANSACTIONS.
- Do NOT use Acreage to determine value unless explicitly asked. Acerage only refers to size of lot and should not be at all used unless size is mentioned
- Use ORDER BY TotalValue DESC or SalePrice DESC depending on what "expensive" means.
- TotalValue is in the OwNER_DETAIL table, and SalePrice is in the SALE_TRANSACTIONS table you will do joins to find this





Do NOT assume TotalValue is in the housing table unless explicitly listed.

Instruction: {{instruction}}
SQL:
""")




sql_translator = LLMChain(
    llm=llm,
    prompt=llm_prompt
)

"""#translate query to natural language"""

def translate(natural_language: str) -> str:
    natural_language_clean = natural_language.lower().strip()
    db_name = db._engine.url.database
    return sql_translator.run(instruction=natural_language).strip()

"""#Query

"""

def run_query(sql: str, user_prompt: str):
# Capitalize all values
    sql = re.sub(
      r"'([^']*)'",
      lambda m: f"'{m.group(1).upper()}'",
      sql
    )

    # Execute the SQL query
    try:
        with db._engine.begin() as conn:
            result_proxy = conn.execute(text(sql))

            if result_proxy.returns_rows:
                rows = result_proxy.fetchall()
                columns = result_proxy.keys()
                return {
                    "status": "success",
                    "data": rows,
                    "columns": columns,
                    "sql": sql
                }
            else:
                return {
                    "status": "success",
                    "data": f"{result_proxy.rowcount} row(s) affected.",
                    "columns": [],
                    "sql": sql
                }

    except Exception as e:
        return f"STOP: SQL error â€“ {str(e).splitlines()[0] if str(e).splitlines() else str(e)}"

"""#langgraph"""

def sql_node(state):
    result = run_query(state["sql"], state["user_prompt"])
    return {"result": result}



class SQLState(TypedDict):
    user_prompt: str
    sql: str
    result: str

graph = StateGraph(SQLState)
graph.add_node("query", sql_node)
graph.set_entry_point("query")
graph.set_finish_point("query")
compiled = graph.compile()

"""#output format"""

def output_format(state_output: dict):
    result = state_output.get("result", "")

    # Handle stop error strings
    if isinstance(result, str) and result.startswith("STOP:"):
        print("\nStopped:")
        print(result.removeprefix("STOP:").strip())
        return

    # Everything else is assumed to be a dict
    sql = result.get("sql", "(SQL unknown)")
    print(f"\n SQL Query Executed:\n{sql}")

    if result.get("status") == "success":
        data = result["data"]
        columns = result.get("columns", [])

        if columns and isinstance(data, list):
            df = pd.DataFrame(data, columns=columns)
            print("\nSuccess (Table):")
            print(df.to_string(index=False))
        else:
            print("\nSuccess:")
            print(data)
    else:
        print("\nError:")
        print(result.get("error", "Unknown error"))

"""#user input"""

def housing_queries():
    print("\nWelcome to the Housing Database (MySQL) Query Interface.")
    print("Type 'exit' to return to the main menu.")
    while True:
        user_prompt = input("Enter your query: ").strip()
        if user_prompt.lower() == "exit":
            break

        sql_query = translate(user_prompt)

        state_output = compiled.invoke({
            "user_prompt": user_prompt,
            "sql": sql_query
        })

        output_format(state_output)

