# -*- coding: utf-8 -*-
"""SQL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G0NdK9_oN__K996NcdEZWDfMQTEzN52j

#Install
"""

#!pip install langchain openai pymysql sqlalchemy

"""#setup"""

import os
import re
import pandas as pd
from langchain import OpenAI
from langchain.chains.llm import LLMChain
from langchain.prompts import PromptTemplate
from sqlalchemy import create_engine, inspect, text
from langchain import SQLDatabase

"""#OpenAI Key"""

os.environ['OPENAI_API_KEY'] = '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'

"""#Connect to DB"""

db = SQLDatabase.from_uri("mysql+pymysql://admin:Dsci-551@database-1.cjc8aikg8tmh.us-east-2.rds.amazonaws.com/DSCI551")
llm = OpenAI(temperature=0)


"""#Create LLM"""

#inspect the schema so the llm knows all columns
inspector = inspect(db._engine)
def describe_schema():
    schema = []
    for table in inspector.get_table_names():
        columns = inspector.get_columns(table)
        col_info = [f"{col['name']} ({col['type']})" for col in columns]
        schema.append(f"{table}: {', '.join(col_info)}")
    return "\n".join(schema)


llm_prompt = PromptTemplate.from_template(f"""
The database contains the following tables and their columns:

{describe_schema()}

ONLY output a valid MySQL SQL query. Do NOT explain or describe anything.
Do NOT guess or invent table or column names. Use only what's listed.

- All tables share the key UniqueID.
- To combine columns from different tables, use JOINs on UniqueID.
- Always use JOINs on UniqueID across the three main tables.
- Use only these valid table names:
  - OWNER_DETAIL
  - PROPERTY_INFO
  - SALE_TRANSACTIONS
- Do NOT use `OWNER_DETAILS`, `PROPERTY_INFOS`, etc.
- TABLE NAMES are always in CAPS
- When updating values check all tables - sometimes updates require referencing other tables
- HOUSE == PROPERTY, do not search for a specific house or property field it does not exist.
- LandUse exists but is not used to find houses (who owns a house will not use land use as house is property)
- Use `IS NULL` to match NULL fields instead of `= NULL`.
- Name is not the UniqueID
- Output valid, complete MySQL statements.
- Never return explanatory text before or after SQL.
- Use one statement per SQL query.
- Duplex is in land use
- Always quote string and VARCHAR values.
- You may insert only one column if that's all the user provided.
- Do not include the rest unless they are required (NOT NULL with no default).
- For example: INSERT INTO property_info (UniqueID) VALUES ('999');
- run SHOW TABLES when asked tabout the tables (ex: what are all the tables, what are the tables, what tables exit, show existing tables, show me the tables, show me all the tables, list the tables, list all the table)
- run SHOW COLUMNS from table_name when asked about the columns and names (ex: what are the column names in the tables, what  are all the col names, col names, column names, what are all the columns in table, what are the columnsin table, what columns exit in table, show existing columns in table, show me the columns in table, show me all the columns in table, list the columns in table, list all the columns in table)
- ex: run show columns from property_info when asked about columns in property info
- Do not reference or use the column Acreage in any part of the SQL query, including filters, joins, selects, or conditions unless explictely mentioned
- do not have a single line about property acerage unless specifically mentioned! (that means no property acerage is null no property acerage is not null nothing of property acerage should exist unless it is mentioned explicitly)
- when asking most or least you should limit to one
- Insert into OWNER_DETAILS when the user specifies an owner or OwnerName.
- The OWNER_DETAILS table has: UniqueID (primary key), OwnerName, ParcelID, etc.
- Do NOT insert into PROPERTY_INFO unless the instruction is about property details like acreage, bedrooms, or address.
- Insert into SALE_TRANSACTIONS when the user specifies a sale or transaction
- The SALE_TRANSACTION Table has UniqueID as primary key
- "Most expensive house" means the highest TotalValue, "cheapest house" means lowest total value from OWNER_DETAIL or highest/lowest SalePrice from SALE_TRANSACTIONS.
- Do NOT use Acreage to determine value unless explicitly asked. Acerage only refers to size of lot and should not be at all used unless size is mentioned
- Use ORDER BY TotalValue DESC or SalePrice DESC depending on what "expensive" means.
- TotalValue exists in OWNER_DETAIL, not in PROPERTY_INFO.
- SalePrice exists in SALE_TRANSACTIONS, not in PROPERTY_INFO
- If the prompt includes "most expensive house," use ORDER BY TotalValue DESC from OWNER_DETAIL.
- Do not reference PROPERTY_INFO.TotalValue — it does not exist.
- When querying INFORMATION_SCHEMA (e.g., to find columns or tables), always use UPPER() on both sides of comparisons. (Ex: SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE UPPER(TABLE_NAME) = 'PROPERTY_INFO' AND UPPER(DATA_TYPE) = 'INT';)
- Do NOT assume TotalValue is in the housing table unless explicitly listed.

Instruction: {{instruction}}
SQL:
""")



# creates the chain that will be run against the prompt
sql_translator = LLMChain(
    llm=llm,
    prompt=llm_prompt
)

"""#translate natural langugae to query"""

#generate query
def translate(natural_language: str) -> str:
    return sql_translator.run(instruction=natural_language).strip()

"""#Query

"""

def run_query(sql: str, user_prompt: str):
# Capitalize all values
    sql = re.sub(
      r"'([^']*)'",
      lambda m: f"'{m.group(1).upper()}'",
      sql
    )

    # Execute the SQL query
    try:
        with db._engine.begin() as conn:
            query_result = conn.execute(text(sql))

            #returns in MySQL format
            if query_result.returns_rows:
                rows = query_result.fetchall()
                columns = query_result.keys()
                return {
                    "status": "success",
                    "data": rows,
                    "columns": columns,
                    "sql": sql
                }
            #table in MySQL format
            else:
                return {
                    "status": "success",
                    "data": f"{query_result.rowcount} row(s) affected.",
                    "columns": [],
                    "sql": sql
                }

    except Exception as e:
        return f"STOP: SQL error – {str(e)}"


"""#output format"""

def output_format(result):
    #in case of a stop error
    if isinstance(result, str) and result.startswith("STOP:"):
        print(result)  
        return

    #shows the query generated by the llm
    sql = result.get("sql", "(SQL unknown)")
    print(f"\n SQL Query Executed:\n{sql}")

    #Handles successful query responses
    if result.get("status") == "success":
        data = result["data"]
        columns = result.get("columns", [])

        #for tabular responses
        if columns and isinstance(data, list):
            df = pd.DataFrame(data, columns=columns)
            print("\n Table:")
            print(df.to_string(index=False))
        
        #for non tabular responses
        else:
            print("\nSuccess:")
            print(data)
    else:
        print("\nError:")
        print(result.get("Unknown error"))

"""#user input (has been modified for app.py)"""

def housing_queries():
    print("Type 'exit' to return to the main menu.\n")

    while True:
        user_prompt = input("Enter your query: ").strip()
        if user_prompt.lower() == "exit":
            break

        try:
            sql_query = translate(user_prompt)
            result = run_query(sql_query, user_prompt)
            output_format(result)
        except Exception as e:
            print(f"\n error: {e}\n")
